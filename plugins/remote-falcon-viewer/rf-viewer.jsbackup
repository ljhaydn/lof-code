(function () {
  const base = (window.RFViewer && RFViewer.base) ? RFViewer.base : '';

  const viewerRoot  = document.getElementById('rf-viewer');
  const statusPanel = document.querySelector('.rf-status-panel');
  const gridEl      = document.getElementById('rf-grid');

  const nowTitleEl  = document.getElementById('rf-now-title');
  const nowArtistEl = document.getElementById('rf-now-artist');
  const nextTitleEl = document.getElementById('rf-next-title');
  const modeEl      = document.getElementById('rf-mode-value');

  let lastActionTimes = {};
  const ACTION_COOLDOWN = 15000; // 15s

  let currentMode = 'UNKNOWN';
  let currentControlEnabled = false;
  let currentVisibleSequences = [];

  /* -------------------------
   * Toast
   * ------------------------- */

  function showToast(message, type = 'success') {
    let toast = document.getElementById('rf-toast');

    if (!toast) {
      toast = document.createElement('div');
      toast.id = 'rf-toast';
      toast.className = 'rf-toast';
      document.body.appendChild(toast);
    }

    toast.classList.remove('rf-toast--success', 'rf-toast--error');

    if (type === 'error') {
      toast.classList.add('rf-toast--error');
    } else {
      toast.classList.add('rf-toast--success');
    }

    toast.textContent = message;
    toast.classList.add('show');

    setTimeout(() => {
      toast.classList.remove('show');
    }, 2500);
  }

  /* -------------------------
   * Fetch showDetails via WP proxy
   * ------------------------- */

  async function fetchShowDetails() {
    if (!base) return;

    try {
      const res = await fetch(base + '/showDetails');
      if (!res.ok) {
        console.error('[RF] showDetails error:', res.status);
        return;
      }

      const data = await res.json();
      renderShowDetails(data);
    } catch (err) {
      console.error('[RF] showDetails fetch error:', err);
    }
  }

  /* -------------------------
   * Header + Layout helpers
   * ------------------------- */

  function ensureHeader() {
    if (!viewerRoot || !statusPanel) return;

    let header = document.getElementById('rf-viewer-header');
    if (!header) {
      header = document.createElement('div');
      header.id = 'rf-viewer-header';
      header.className = 'rf-viewer-header';

      const headline = document.createElement('div');
      headline.id = 'rf-viewer-headline';
      headline.className = 'rf-viewer-headline';

      const subcopy = document.createElement('div');
      subcopy.id = 'rf-viewer-subcopy';
      subcopy.className = 'rf-viewer-subcopy';

      const controls = document.createElement('div');
      controls.id = 'rf-viewer-controls';
      controls.className = 'rf-viewer-controls';

      header.appendChild(headline);
      header.appendChild(subcopy);
      header.appendChild(controls);

      viewerRoot.insertBefore(header, statusPanel);
    }
  }

  function ensureControls() {
    const controls = document.getElementById('rf-viewer-controls');
    if (!controls) return;

    let surpriseBtn = document.getElementById('rf-surprise-btn');
    if (!surpriseBtn) {
      surpriseBtn = document.createElement('button');
      surpriseBtn.id = 'rf-surprise-btn';
      surpriseBtn.className = 'rf-card-btn';
      surpriseBtn.textContent = 'Surprise me âœ¨';
      controls.appendChild(surpriseBtn);

      surpriseBtn.addEventListener('click', handleSurpriseMe);
    }
  }

  function ensureMainLayout() {
    if (!viewerRoot || !gridEl) return;

    if (!viewerRoot.querySelector('.rf-main-layout')) {
      const layout = document.createElement('div');
      layout.className = 'rf-main-layout';

      const leftCol = document.createElement('div');
      leftCol.className = 'rf-main-left';

      const rightCol = document.createElement('div');
      rightCol.className = 'rf-main-right';

      const extraPanel = document.createElement('div');
      extraPanel.id = 'rf-extra-panel';
      extraPanel.className = 'rf-extra-panel';

      viewerRoot.removeChild(gridEl);
      leftCol.appendChild(gridEl);
      rightCol.appendChild(extraPanel);

      layout.appendChild(leftCol);
      layout.appendChild(rightCol);

      viewerRoot.appendChild(layout);
    }
  }

  function updateHeaderCopy(mode, enabled, prefs, queueLength) {
    const headlineEl = document.getElementById('rf-viewer-headline');
    const subcopyEl  = document.getElementById('rf-viewer-subcopy');
    if (!headlineEl || !subcopyEl) return;

    const requestLimit   = prefs.jukeboxRequestLimit || null;
    const locationMethod = prefs.locationCheckMethod || 'NONE';

    if (!enabled) {
      headlineEl.textContent = 'Viewer control is currently paused';
      subcopyEl.textContent =
        'You can still enjoy the show â€” weâ€™ll turn song requests and voting back on soon.';
      return;
    }

    if (mode === 'JUKEBOX') {
      headlineEl.textContent = 'Tap a song to request it ðŸŽ§';

      const bits = ['Requests join the queue in the order they come in.'];

      if (queueLength > 0) {
        bits.push(`There ${queueLength === 1 ? 'is' : 'are'} currently ${queueLength} song${queueLength === 1 ? '' : 's'} in the queue.`);
      }

      if (requestLimit && requestLimit > 0) {
        bits.push(`You can request up to ${requestLimit} song${requestLimit > 1 ? 's' : ''} per session.`);
      }
      if (locationMethod && locationMethod !== 'NONE') {
        bits.push('Viewer control may be limited to guests near the show location.');
      }

      subcopyEl.textContent = bits.join(' ');
      return;
    }

    if (mode === 'VOTING') {
      headlineEl.textContent = 'Vote for your favorites ðŸ—³ï¸';
      subcopyEl.textContent =
        'Songs with the most votes rise to the top. Tap a track below to help decide what plays next.';
      return;
    }

    headlineEl.textContent = 'Interactive show controls';
    subcopyEl.textContent =
      'Use the controls below to interact with the Lights on Falcon show in real time.';
  }

  /* -------------------------
   * Main render
   * ------------------------- */

  function renderShowDetails(data) {
    if (!data || typeof data !== 'object') return;

    const prefs        = data.preferences || {};
    const sequences    = Array.isArray(data.sequences) ? data.sequences : [];
    const rawRequests  = Array.isArray(data.requests) ? data.requests : [];
    const rawVotes     = Array.isArray(data.votes)    ? data.votes    : [];

    currentMode           = prefs.viewerControlMode || 'UNKNOWN';
    currentControlEnabled = !!prefs.viewerControlEnabled;

    if (typeof currentMode === 'string') {
      currentMode = currentMode.toUpperCase();
    }

    const modeLabel = formatModeLabel(currentMode, currentControlEnabled);

    const playingNowRaw  = data.playingNow || '';
    const playingNextRaw = data.playingNext || '';

    ensureHeader();
    ensureControls();
    ensureMainLayout();

    // Find sequence objects by name/displayName
    const nowSeq = sequences.find(s =>
      s.name === playingNowRaw || s.displayName === playingNowRaw
    ) || null;

    // First try API's playingNext, then fall back to the first queued request
    let nextSeq = sequences.find(s =>
      s.name === playingNextRaw || s.displayName === playingNextRaw
    ) || null;

    if (!nextSeq && rawRequests.length > 0 && rawRequests[0].sequence) {
      nextSeq = rawRequests[0].sequence;
    }

    const nowDisplay  = nowSeq ? (nowSeq.displayName || nowSeq.name || playingNowRaw) : (playingNowRaw || 'Nothing currently playing');
    const nextDisplay = nextSeq ? (nextSeq.displayName || nextSeq.name || playingNextRaw) : (playingNextRaw || 'â€”');
    const nowArtist   = nowSeq && nowSeq.artist ? nowSeq.artist : '';

    const nowKey  = nowSeq  ? (nowSeq.name  || nowSeq.displayName) : playingNowRaw;
    const nextKey = nextSeq ? (nextSeq.name || nextSeq.displayName) : playingNextRaw;

    if (modeEl)      modeEl.textContent      = modeLabel;
    if (nowTitleEl)  nowTitleEl.textContent  = nowDisplay;
    if (nextTitleEl) nextTitleEl.textContent = nextDisplay;
    if (nowArtistEl) nowArtistEl.textContent = nowArtist;

    const queueLength = rawRequests.length || 0;
    updateHeaderCopy(currentMode, currentControlEnabled, prefs, queueLength);

    if (!gridEl) return;
    gridEl.innerHTML = '';

    const visibleSequences = sequences
      .filter(s => s.visible && s.active)
      .sort((a, b) => {
        const ao = (typeof a.order === 'number') ? a.order : 9999;
        const bo = (typeof b.order === 'number') ? b.order : 9999;
        return ao - bo;
      });

    currentVisibleSequences = visibleSequences;

    visibleSequences.forEach(seq => {
      const card = document.createElement('div');
      card.className = 'rf-card';

      const isNow = nowKey && (seq.name === nowKey || seq.displayName === nowKey);
      const isNext = nextKey && (seq.name === nextKey || seq.displayName === nextKey);

      if (isNow) {
        card.classList.add('rf-card--now-playing');
      } else if (isNext) {
        card.classList.add('rf-card--next');
      }

      const durationSeconds = seq.duration || 0;
      const minutes = Math.floor(durationSeconds / 60);
      const seconds = durationSeconds % 60;
      const niceDuration = minutes + ':' + String(seconds).padStart(2, '0');

      const buttonLabel  = getButtonLabel(currentMode, currentControlEnabled);
      const displayTitle = seq.displayName || seq.name || 'Untitled';
      const artist       = seq.artist || '';

      card.innerHTML = `
        <div class="rf-card-title">${escapeHtml(displayTitle)}</div>
        <div class="rf-card-artist">${escapeHtml(artist)}</div>
        <div class="rf-card-meta">
          <span class="rf-card-duration">Runtime ${niceDuration}</span>
        </div>
        <div class="rf-card-actions">
          <button class="rf-card-btn" ${!currentControlEnabled ? 'disabled' : ''}>
            ${escapeHtml(buttonLabel)}
          </button>
        </div>
      `;

      if (isNow || isNext) {
        const badge = document.createElement('div');
        badge.className = 'rf-card-badge ' + (isNow ? 'rf-card-badge--now' : 'rf-card-badge--next');
        badge.textContent = isNow ? 'Now playing' : 'Next up';
        card.appendChild(badge);
      }

      const btn = card.querySelector('.rf-card-btn');
      if (btn && currentControlEnabled) {
        btn.addEventListener('click', () => handleAction(currentMode, seq, btn));
      }

      gridEl.appendChild(card);
    });

    renderExtraPanel(currentMode, currentControlEnabled, data);
  }

  /* -------------------------
   * Extra panel (queue / leaderboard)
   * ------------------------- */

  function renderExtraPanel(mode, enabled, data) {
    const extra = document.getElementById('rf-extra-panel');
    if (!extra) return;

    extra.innerHTML = '';

    if (!enabled) {
      extra.innerHTML = `
        <div class="rf-extra-title">Viewer control paused</div>
        <div class="rf-extra-sub">
          When interactive mode is back on, youâ€™ll see the live request queue or top-voted songs here.
        </div>
      `;
      return;
    }

    if (mode === 'JUKEBOX') {
      renderQueue(extra, data);
    } else if (mode === 'VOTING') {
      renderLeaderboard(extra, data);
    } else {
      extra.innerHTML = `
        <div class="rf-extra-title">Show status</div>
        <div class="rf-extra-sub">
          Interactive controls are on, but this mode doesnâ€™t expose queue or vote data.
        </div>
      `;
    }
  }

  /**
   * Queue renderer â€“ SUPER DIRECT.
   * Uses data.requests as-is: [{ sequence: {...}, position: N, ... }]
   */
  function renderQueue(extra, data) {
    const rawRequests = Array.isArray(data.requests) ? data.requests : [];

    extra.innerHTML = `
      <div class="rf-extra-title">Up Next Queue</div>
      <div class="rf-extra-sub">
        Songs requested by guests appear here in the order theyâ€™re queued.
      </div>
    `;

    const list = document.createElement('ul');
    list.className = 'rf-queue-list';

    if (!rawRequests.length) {
      const empty = document.createElement('div');
      empty.className = 'rf-extra-sub';
      empty.textContent =
        'Requests are handled behind the scenes by Remote Falcon. When your pick is ready, youâ€™ll see it glow as â€œNext Up.â€';
      extra.appendChild(list);
      extra.appendChild(empty);
      return;
    }

    rawRequests.forEach((item, idx) => {
      if (!item || typeof item !== 'object') return;

      const seq = (item.sequence && typeof item.sequence === 'object') ? item.sequence : {};
      const displayTitle = seq.displayName || seq.name || 'Untitled';
      const artist       = seq.artist || '';
      const pos          = (typeof item.position === 'number')
        ? item.position
        : idx + 1;

      const li = document.createElement('li');
      li.className = 'rf-queue-item';
      li.innerHTML = `
        <span class="rf-queue-position">#${pos}</span>
        <span class="rf-queue-song">${escapeHtml(displayTitle)}</span>
        ${artist ? `<span class="rf-queue-artist">${escapeHtml(artist)}</span>` : ''}
      `;
      list.appendChild(li);
    });

    extra.appendChild(list);
  }

  /**
   * Leaderboard renderer (for VOTING mode).
   * Uses data.votes: [{ sequence: {...}, sequenceGroup: {...}, votes: N, ... }]
   */
  function renderLeaderboard(extra, data) {
    const rawVotes = Array.isArray(data.votes) ? data.votes : [];

    const items = rawVotes.map(item => {
      if (!item || typeof item !== 'object') return null;

      let seqObj = null;
      if (item.sequence && typeof item.sequence === 'object') {
        seqObj = item.sequence;
      } else if (item.sequenceGroup && typeof item.sequenceGroup === 'object') {
        seqObj = item.sequenceGroup;
      }

      if (!seqObj) return null;

      const displayTitle = seqObj.displayName || seqObj.name || 'Untitled';
      const votes        = typeof item.votes === 'number' ? item.votes : 0;
      const artist       = seqObj.artist || '';

      return {
        name: displayTitle,
        artist,
        votes
      };
    }).filter(Boolean);

    items.sort((a, b) => b.votes - a.votes);
    const top = items.slice(0, 5);

    extra.innerHTML = `
      <div class="rf-extra-title">Top Voted</div>
      <div class="rf-extra-sub">
        Songs with the most votes are most likely to play next.
      </div>
    `;

    const list = document.createElement('ul');
    list.className = 'rf-leaderboard-list';

    if (!top.length) {
      const empty = document.createElement('div');
      empty.className = 'rf-extra-sub';
      empty.textContent = 'No votes yet â€” tap a song to send the first one.';
      extra.appendChild(list);
      extra.appendChild(empty);
      return;
    }

    top.forEach((item, idx) => {
      const li = document.createElement('li');
      li.className = 'rf-leaderboard-item';
      li.innerHTML = `
        <span class="rf-leaderboard-rank">#${idx + 1}</span>
        <span class="rf-leaderboard-song">${escapeHtml(item.name)}</span>
        <span class="rf-leaderboard-votes">${item.votes} vote${item.votes === 1 ? '' : 's'}</span>
      `;
      list.appendChild(li);
    });

    extra.appendChild(list);
  }

  /* -------------------------
   * Actions (request / vote)
   * ------------------------- */

  function getButtonLabel(mode, controlEnabled) {
    if (!controlEnabled) return 'Viewer control disabled';
    if (mode === 'JUKEBOX') return 'Request this song';
    if (mode === 'VOTING')  return 'Vote for this song';
    return 'Request';
  }

  function formatModeLabel(mode, enabled) {
    const prettyMode = mode || 'UNKNOWN';
    const status = enabled ? 'viewer control ON' : 'viewer control OFF';
    return `${prettyMode} (${status})`;
  }

  async function handleAction(mode, seq, btn) {
    if (!base) return;

    const endpoint = (mode === 'VOTING') ? '/vote' : '/request';
    const sequenceKey = seq.name;
    const now = Date.now();

    if (lastActionTimes[sequenceKey] && now - lastActionTimes[sequenceKey] < ACTION_COOLDOWN) {
      const remaining = Math.ceil((ACTION_COOLDOWN - (now - lastActionTimes[sequenceKey])) / 1000);
      showToast(`Please wait ${remaining}s before interacting with this song again.`, 'error');
      return;
    }

    lastActionTimes[sequenceKey] = now;

    if (btn) {
      btn.disabled = true;
      btn.textContent = (mode === 'VOTING') ? 'Sending voteâ€¦' : 'Sending requestâ€¦';
    }

    const payload = {
      sequence: seq.name  // matches OpenAPI: requestSequence.sequence
    };

    try {
      const res = await fetch(base + endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const data = await res.json().catch(() => null);

      if (res.ok) {
        const codeMessage = data && data.message ? ` (${data.message})` : '';
        const msg = (mode === 'VOTING')
          ? `Vote sent! Youâ€™re helping pick the next song.${codeMessage}`
          : `Request sent! Youâ€™re in the queue.${codeMessage}`;
        showToast(msg, 'success');
      } else {
        const errMsg = (data && (data.message || data.error)) || `HTTP ${res.status}`;
        showToast('Remote Falcon issue: ' + errMsg, 'error');
      }

      // Refresh showDetails after a request/vote so queue / next-up update
      fetchShowDetails();
    } catch (err) {
      console.error('[RF] Action error:', err);
      showToast('Network issueâ€”please try again.', 'error');
    } finally {
      setTimeout(() => {
        if (btn) {
          btn.disabled = false;
          btn.textContent = getButtonLabel(mode, true);
        }
      }, 1000);
    }
  }

  /* -------------------------
   * Surprise Me
   * ------------------------- */

  function handleSurpriseMe() {
    if (!currentControlEnabled) {
      showToast('Viewer control is currently paused.', 'error');
      return;
    }

    if (!currentVisibleSequences.length) {
      showToast('No songs available right now.', 'error');
      return;
    }

    const randomIndex = Math.floor(Math.random() * currentVisibleSequences.length);
    const seq = currentVisibleSequences[randomIndex];

    handleAction(currentMode, seq, null);
  }

  /* -------------------------
   * Utils
   * ------------------------- */

  function escapeHtml(str) {
    if (typeof str !== 'string') return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  /* -------------------------
   * Init
   * ------------------------- */

  fetchShowDetails();
  setInterval(fetchShowDetails, 15000);
})();
